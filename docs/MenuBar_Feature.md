# Menu Bar Feature: Design and Implementation

This document details the design and implementation of the "Menu Bar App," a feature that moves the bike share dashboard from the terminal to the macOS system menu bar for "always-on" glanceability.

---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Design Goals](#design-goals)
3. [Technology Selection: SwiftBar](#technology-selection-swiftbar)
4. [Architecture: The "Engine" Pattern](#architecture-the-engine-pattern)
5. [Implementation Details](#implementation-details)
6. [UX Decisions: The "Traffic Light"](#ux-decisions-the-traffic-light)
7. [Challenges & Solutions](#challenges--solutions)
8. [How it Works (Under the Hood)](#how-it-works-under-the-hood)

---

## Problem Statement

While the Terminal UI (TUI) is powerful, it requires the user to actively open a terminal window and type a command (or keep a window occupying screen space).

**The User Need:**
> "Something where the user can quickly glance at it... A Mac menu bar item by my clock."

Commuters need to know the status of their trip *before* they decide to leave, without context-switching away from their current work.

---

## Design Goals

| Goal | Description |
|------|-------------|
| **Glanceability** | Status must be visible 100% of the time without interaction. |
| **Zero Friction** | No need to open apps or type commands. |
| **Consistency** | Must use the exact same prediction logic as the terminal tool. |
| **Low Resource Usage** | Shouldn't drain battery or hammer APIs unnecessarily. |

---

## Technology Selection: SwiftBar

We evaluated three approaches to build a menu bar app:

### Option 1: Native macOS App (Swift/Xcode)
*   **Pros:** High performance, native UI controls.
*   **Cons:** High development effort, requires compiling, separate codebase from Python logic.

### Option 2: Web Wrapper (MenubarX)
*   **Pros:** Infinite styling possibilities (CSS/HTML).
*   **Cons:** Heavy resource usage (running a browser instance), requires a local web server.

### Option 3: SwiftBar (Selected)
*   **Pros:** Lightweight, open-source, runs standard scripts (Bash/Python).
*   **Cons:** Limited UI (text-based lists), but sufficient for our needs.

**Decision:** We chose **SwiftBar** because it allowed us to reuse our existing Python codebase with zero overhead. We essentially just added a "New View" to our existing "Model".

---

## Architecture: The "Engine" Pattern

To support this feature, we had to refactor the application from a linear script into a modular engine.

1.  **The Logic (Model):** `get_dashboard_data()` calculates predictions and returns a raw Dictionary. It knows nothing about the screen.
2.  **The Terminal View:** `build_dashboard_group()` takes that Dict and renders Rich panels.
3.  **The Menu Bar View:** `render_swiftbar()` takes that *same* Dict and renders SwiftBar-compatible text stream.

This separation of concerns meant we didn't have to rewrite any bike logic. We just wrote a new "printer."

---

## Implementation Details

### The Wrapper Script
SwiftBar requires a file in its Plugin folder to execute. We couldn't just symlink our Python script because we needed to pass arguments (`--swiftbar`).

**The Solution:** A wrapper script (`bikes.1m.sh`) generated by our installer:

```bash
#!/bin/bash
"/usr/bin/python3" "/path/to/src/bikes.py" --swiftbar
```

*   **`.1m`:** Tells SwiftBar to run this script every 1 minute.
*   **`--swiftbar`:** Tells our Python app to output the special text format instead of the TUI.

---

## UX Decisions: The "Traffic Light"

We iterated on the visual design to maximize information density in a tiny space.

### Iteration 1: Text & Icons (Rejected)
`游 MEDIUM`
*   **Critique:** Too wide. "MEDIUM" takes up valuable menu bar space.

### Iteration 2: Double Icons (The Glitch)
`游 游리`
*   **Issue:** Due to a coding redundancy, we accidentally rendered both a text emoji and an SF Symbol image.
*   **Critique:** "Why are there two bike icons?"

### Iteration 3: The Traffic Light (Final)
<img src="../assets/swiftbar_icon.png" height="30" alt="Traffic Light Icon">

`游리 | sfimage=bicycle`
*   **Visual:** A colored circle (Status) + A bicycle icon (Context).
*   **Logic:**
    *   游릭 (High Confidence)
    *   游리 (Medium Confidence)
    *   游댮 (Low Confidence)
*   **Result:** Instantly readable status using native macOS aesthetics.

### Final Dropdown UI
<img src="../assets/swiftbar_dropdown.png" width="60%" alt="Menu Bar Dropdown">

---

## Challenges & Solutions

### 1. The "Missing Library" Crash
**Problem:** The user installed dependencies (`rich`) in a virtual environment or specific Python setup, but SwiftBar executes scripts using the system default `python3`.
**Result:** The script crashed silently because it couldn't find `rich`.

**Solution:** We updated the `install_swiftbar.sh` script to capture the *current* Python path (`$(which python3)`) and hardcode that into the wrapper script. This guarantees the plugin runs in the exact same environment where it was installed.

### 2. Live vs. Cached Data
**Problem:** Users expect "Click" to mean "Refresh."
**Reality:** SwiftBar shows the output of the *last* run (cached). It runs on a schedule (every 1 min).

**Solution:**
1.  Accept the 1-minute latency (acceptable for commuting).
2.  Add a generic **"Refresh"** button at the bottom of the dropdown that forces an immediate update.

---

## How it Works (Under the Hood)

1.  **The Trigger:** Every 60 seconds, SwiftBar (the macOS app) executes the `bikes.1m.sh` wrapper script in a hidden background process.
2.  **The Execution:** The wrapper runs your Python script with the `--swiftbar` flag.
3.  **The Output:** Your script fetches API data, calculates stats, and `print()`s text to Standard Output (stdout).
    *   Line 1 becomes the Menu Bar Label.
    *   Lines after `---` become the Dropdown Menu.
4.  **The Display:** SwiftBar captures this text and renders it as a native macOS menu.

The Python application **does not run continuously**. It wakes up, fetches data, prints text, and dies. SwiftBar handles the persistence.
